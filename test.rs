// Generated by rust-peg. Do not edit.
#![allow(non_snake_case, unused)]
use self::RuleResult::{Matched, Failed};
fn escape_default(s: &str) -> String {
    s.chars().flat_map(|c| c.escape_default()).collect()
}
fn char_range_at(s: &str, pos: usize) -> (char, usize) {
    let c = &s[pos..].chars().next().unwrap();
    let next_pos = pos + c.len_utf8();
    (*c, next_pos)
}
#[derive(Clone)]
enum RuleResult<T> { Matched(usize, T), Failed, }
#[derive(PartialEq, Eq, Debug, Clone)]
pub struct ParseError {
    pub line: usize,
    pub column: usize,
    pub offset: usize,
    pub expected: ::std::collections::HashSet<&'static str>,
}
pub type ParseResult<T> = Result<T, ParseError>;
impl ::std::fmt::Display for ParseError {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter)
     -> ::std::result::Result<(), ::std::fmt::Error> {
        try!(write ! (
             fmt , "error at {}:{}: expected " , self . line , self . column
             ));
        if self.expected.len() == 0 {
            try!(write ! ( fmt , "EOF" ));
        } else if self.expected.len() == 1 {
            try!(write ! (
                 fmt , "`{}`" , escape_default (
                 self . expected . iter (  ) . next (  ) . unwrap (  ) ) ));
        } else {
            let mut iter = self.expected.iter();
            try!(write ! (
                 fmt , "one of `{}`" , escape_default (
                 iter . next (  ) . unwrap (  ) ) ));
            for elem in iter {
                try!(write ! ( fmt , ", `{}`" , escape_default ( elem ) ));
            }
        }
        Ok(())
    }
}
impl ::std::error::Error for ParseError {
    fn description(&self) -> &str { "parse error" }
}
fn slice_eq(input: &str, state: &mut ParseState, pos: usize, m: &'static str)
 -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let l = m.len();
    if input.len() >= pos + l &&
           &input.as_bytes()[pos..pos + l] == m.as_bytes() {
        Matched(pos + l, ())
    } else { state.mark_failure(pos, m) }
}
fn slice_eq_case_insensitive(input: &str, state: &mut ParseState, pos: usize,
                             m: &'static str) -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let mut used = 0usize;
    let mut input_iter = input[pos..].chars().flat_map(|x| x.to_uppercase());
    for m_char_upper in m.chars().flat_map(|x| x.to_uppercase()) {
        used += m_char_upper.len_utf8();
        let input_char_result = input_iter.next();
        if input_char_result.is_none() ||
               input_char_result.unwrap() != m_char_upper {
            return state.mark_failure(pos, m);
        }
    }
    Matched(pos + used, ())
}
fn any_char(input: &str, state: &mut ParseState, pos: usize)
 -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    if input.len() > pos {
        let (_, next) = char_range_at(input, pos);
        Matched(next, ())
    } else { state.mark_failure(pos, "<character>") }
}
fn pos_to_line(input: &str, pos: usize) -> (usize, usize) {
    let mut remaining = pos;
    let mut lineno: usize = 1;
    for line in input.lines() {
        let line_length = line.len() + 1;
        if remaining < line_length { return (lineno, remaining + 1); }
        remaining -= line_length;
        lineno += 1;
    }
    return (lineno, remaining + 1);
}
struct ParseState<'input> {
    max_err_pos: usize,
    expected: ::std::collections::HashSet<&'static str>,
    _phantom: ::std::marker::PhantomData<&'input ()>,
}
impl <'input> ParseState<'input> {
    fn new() -> ParseState<'input> {
        ParseState{max_err_pos: 0,
                   expected: ::std::collections::HashSet::new(),
                   _phantom: ::std::marker::PhantomData,}
    }
    fn mark_failure(&mut self, pos: usize, expected: &'static str)
     -> RuleResult<()> {
        if pos > self.max_err_pos {
            self.max_err_pos = pos;
            self.expected.clear();
        }
        if pos == self.max_err_pos { self.expected.insert(expected); }
        Failed
    }
}
fn parse_start<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<Ast> {
    parse_block(input, state, pos)
}
fn parse_block<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<Ast> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    parse_Comment(input,
                                                                  state, pos);
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            Matched(repeat_pos, ())
                                        };
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    {
                                                        let choice_res =
                                                            parse_Tag(input,
                                                                      state,
                                                                      pos);
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed =>
                                                            parse_buffer(input,
                                                                         state,
                                                                         pos),
                                                        }
                                                    };
                                                match seq_res {
                                                    Matched(pos, t) => {
                                                        {
                                                            let match_str =
                                                                &input[start_pos..pos];
                                                            Matched(pos,
                                                                    {
                                                                        return t
                                                                    })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    Matched(repeat_pos, repeat_value)
                };
            match seq_res {
                Matched(pos, s) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        parse_Comment(input, state, pos);
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, ())
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { return Ast::Block(s) })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_eol<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<()> {
    {
        let choice_res = slice_eq(input, state, pos, "\n");
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res = slice_eq(input, state, pos, "\r\n");
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res = slice_eq(input, state, pos, "\r");
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    slice_eq(input, state, pos, "\u{2028}");
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    slice_eq(input, state, pos, "\u{2029}"),
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_ws<'input>(input: &'input str, state: &mut ParseState<'input>,
                    pos: usize) -> RuleResult<()> {
    {
        let choice_res =
            if input.len() > pos {
                let (ch, next) = char_range_at(input, pos);
                match ch {
                    '\t' | 'v' | 'f' | ' ' | '\u{a0}' | '\u{feff}' =>
                    Matched(next, ()),
                    _ => state.mark_failure(pos, "[\tvf \u{a0}\u{feff}]"),
                }
            } else { state.mark_failure(pos, "[\tvf \u{a0}\u{feff}]") };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => parse_eol(input, state, pos),
        }
    }
}
fn parse_opentag<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<()> {
    slice_eq(input, state, pos, "{")
}
fn parse_closetag<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize) -> RuleResult<()> {
    slice_eq(input, state, pos, "}")
}
fn parse_openarray<'input>(input: &'input str, state: &mut ParseState<'input>,
                           pos: usize) -> RuleResult<()> {
    slice_eq(input, state, pos, "(")
}
fn parse_closearray<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<()> {
    slice_eq(input, state, pos, ")")
}
fn parse_string<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<Literal> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\"");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        {
                                            let start_pos = pos;
                                            {
                                                let seq_res =
                                                    {
                                                        let assert_res =
                                                            slice_eq(input,
                                                                     state,
                                                                     pos,
                                                                     "\"");
                                                        match assert_res {
                                                            Failed =>
                                                            Matched(pos, ()),
                                                            Matched(..) =>
                                                            Failed,
                                                        }
                                                    };
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                {
                                                                    let assert_res =
                                                                        parse_eol(input,
                                                                                  state,
                                                                                  pos);
                                                                    match assert_res
                                                                        {
                                                                        Failed
                                                                        =>
                                                                        Matched(pos,
                                                                                ()),
                                                                        Matched(..)
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                };
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            any_char(input,
                                                                                     state,
                                                                                     pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    c)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        &input[start_pos..pos];
                                                                                    Matched(pos,
                                                                                            {
                                                                                                c
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, ())
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "\"");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            let s =
                                                                match_str.to_string();
                                                            Literal::String(s)
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_float<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<Literal> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_integer(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = slice_eq(input, state, pos, ".");
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_unsigned_integer(input, state,
                                                               pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            let f =
                                                                from_str::<f64>(match_str).unwrap();
                                                            Literal::Float(f)
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_unsigned_integer<'input>(input: &'input str,
                                  state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Literal> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            if input.len() > pos {
                                let (ch, next) = char_range_at(input, pos);
                                match ch {
                                    '0' ...'9' => Matched(next, ()),
                                    _ => state.mark_failure(pos, "[0-9]"),
                                }
                            } else { state.mark_failure(pos, "[0-9]") };
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    if repeat_value.len() >= 1usize {
                        Matched(repeat_pos, repeat_value)
                    } else { Failed }
                };
            match seq_res {
                Matched(pos, digits) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos,
                                {
                                    let i =
                                        from_str::<u64>(match_str).unwrap();
                                    Literal::Int(i)
                                })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_signed_integer<'input>(input: &'input str,
                                state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Literal> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "-");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            parse_unsigned_integer(input, state, pos);
                        match seq_res {
                            Matched(pos, n) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos,
                                            {
                                                let x =
                                                    match n {
                                                        Literal::Int(v) =>
                                                        v * -1,
                                                        _ => -1,
                                                    };
                                                Literal::Int(x)
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_integer<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<Literal> {
    {
        let choice_res = parse_signed_integer(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => parse_unsigned_integer(input, state, pos),
        }
    }
}
fn parse_boolean<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<Literal> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "true");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Literal::Bool(true) })
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "false");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Literal::Bool(false) })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_literal<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<Ast> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let choice_res = parse_string(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => {
                            let choice_res = parse_integer(input, state, pos);
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        parse_float(input, state, pos);
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed =>
                                        parse_boolean(input, state, pos),
                                    }
                                }
                            }
                        }
                    }
                };
            match seq_res {
                Matched(pos, l) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, { Ast::Literal(l) })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_keypart<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                if input.len() > pos {
                    let (ch, next) = char_range_at(input, pos);
                    match ch {
                        'a' ...'z' | 'A' ...'Z' | '$' | '_' =>
                        Matched(next, ()),
                        _ => state.mark_failure(pos, "[a-zA-Z$_]"),
                    }
                } else { state.mark_failure(pos, "[a-zA-Z$_]") };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        if input.len() > pos {
                                            let (ch, next) =
                                                char_range_at(input, pos);
                                            match ch {
                                                'a' ...'z' | 'A' ...'Z' | '0'
                                                ...'9' | '$' | '_' =>
                                                Matched(next, ()),
                                                _ =>
                                                state.mark_failure(pos,
                                                                   "[a-zA-Z0-9$_]"),
                                            }
                                        } else {
                                            state.mark_failure(pos,
                                                               "[a-zA-Z0-9$_]")
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, ())
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { match_str.to_string() })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_key<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_keypart(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        {
                                            let seq_res =
                                                slice_eq(input, state, pos,
                                                         ".");
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    parse_keypart(input,
                                                                  state, pos)
                                                }
                                                Failed => Failed,
                                            }
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, ())
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { match_str.to_string() })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_namespace<'input>(input: &'input str, state: &mut ParseState<'input>,
                           pos: usize) -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                if input.len() > pos {
                    let (ch, next) = char_range_at(input, pos);
                    match ch {
                        'a' ...'z' | 'A' ...'Z' => Matched(next, ()),
                        _ => state.mark_failure(pos, "[a-zA-Z]"),
                    }
                } else { state.mark_failure(pos, "[a-zA-Z]") };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        if input.len() > pos {
                                            let (ch, next) =
                                                char_range_at(input, pos);
                                            match ch {
                                                'a' ...'z' | 'A' ...'Z' | '0'
                                                ...'9' | '_' =>
                                                Matched(next, ()),
                                                _ =>
                                                state.mark_failure(pos,
                                                                   "[a-zA-Z0-9_]"),
                                            }
                                        } else {
                                            state.mark_failure(pos,
                                                               "[a-zA-Z0-9_]")
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, ())
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { match_str.to_string() })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_scopeoperator<'input>(input: &'input str,
                               state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<()> {
    slice_eq(input, state, pos, "::")
}
fn parse_identifier<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Ast> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_namespace(input, state, pos);
                    match seq_res {
                        Matched(pos, c) => {
                            {
                                let seq_res =
                                    parse_scopeoperator(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                slice_eq(input, state, pos,
                                                         ".");
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    Ast::Identifier(Some(c),
                                                                                    None)
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res = parse_namespace(input, state, pos);
                            match seq_res {
                                Matched(pos, c) => {
                                    {
                                        let seq_res =
                                            parse_scopeoperator(input, state,
                                                                pos);
                                        match seq_res {
                                            Matched(pos, _) => {
                                                {
                                                    let seq_res =
                                                        parse_key(input,
                                                                  state, pos);
                                                    match seq_res {
                                                        Matched(pos, i) => {
                                                            {
                                                                let match_str =
                                                                    &input[start_pos..pos];
                                                                Matched(pos,
                                                                        {
                                                                            Ast::Identifier(Some(c),
                                                                                            Some(i))
                                                                        })
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let start_pos = pos;
                        {
                            let seq_res = parse_key(input, state, pos);
                            match seq_res {
                                Matched(pos, i) => {
                                    {
                                        let match_str =
                                            &input[start_pos..pos];
                                        Matched(pos,
                                                {
                                                    Ast::Identifier(None,
                                                                    Some(i))
                                                })
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_paramlist<'input>(input: &'input str, state: &mut ParseState<'input>,
                           pos: usize) -> RuleResult<Vec<String>> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_openarray(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_filler(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    {
                                                        let start_pos = pos;
                                                        {
                                                            let seq_res =
                                                                parse_key(input,
                                                                          state,
                                                                          pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        k) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            parse_filler(input,
                                                                                         state,
                                                                                         pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        &input[start_pos..pos];
                                                                                    Matched(pos,
                                                                                            {
                                                                                                k
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    };
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            Matched(repeat_pos, repeat_value)
                                        };
                                    match seq_res {
                                        Matched(pos, p) => {
                                            {
                                                let seq_res =
                                                    parse_filler(input, state,
                                                                 pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_closearray(input,
                                                                                 state,
                                                                                 pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let match_str =
                                                                            &input[start_pos..pos];
                                                                        Matched(pos,
                                                                                {
                                                                                    p
                                                                                })
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_paramset<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize) -> RuleResult<Vec<String>> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_expression(input, state, pos);
                                    match seq_res {
                                        Matched(pos, e) => {
                                            {
                                                let seq_res =
                                                    parse_filler(input, state,
                                                                 pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let match_str =
                                                                &input[start_pos..pos];
                                                            Matched(pos,
                                                                    { e })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    Matched(repeat_pos, repeat_value)
                };
            match seq_res {
                Matched(pos, p) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, { p })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_buffer<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<Ast> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_eol(input, state, pos);
                    match seq_res {
                        Matched(pos, e) => {
                            {
                                let seq_res =
                                    {
                                        let mut repeat_pos = pos;
                                        let mut repeat_value = vec!();
                                        loop  {
                                            let pos = repeat_pos;
                                            let step_res =
                                                parse_ws(input, state, pos);
                                            match step_res {
                                                Matched(newpos, value) => {
                                                    repeat_pos = newpos;
                                                    repeat_value.push(value);
                                                }
                                                Failed => { break ; }
                                            }
                                        }
                                        Matched(repeat_pos, repeat_value)
                                    };
                                match seq_res {
                                    Matched(pos, w) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos,
                                                    {
                                                        Ast::Format(match_str.to_string())
                                                    })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec!();
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                {
                                                    let assert_res =
                                                        parse_Comment(input,
                                                                      state,
                                                                      pos);
                                                    match assert_res {
                                                        Failed =>
                                                        Matched(pos, ()),
                                                        Matched(..) => Failed,
                                                    }
                                                };
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let seq_res =
                                                            {
                                                                let assert_res =
                                                                    parse_opentag(input,
                                                                                  state,
                                                                                  pos);
                                                                match assert_res
                                                                    {
                                                                    Failed =>
                                                                    Matched(pos,
                                                                            ()),
                                                                    Matched(..)
                                                                    => Failed,
                                                                }
                                                            };
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        {
                                                                            let assert_res =
                                                                                parse_closetag(input,
                                                                                               state,
                                                                                               pos);
                                                                            match assert_res
                                                                                {
                                                                                Failed
                                                                                =>
                                                                                Matched(pos,
                                                                                        ()),
                                                                                Matched(..)
                                                                                =>
                                                                                Failed,
                                                                            }
                                                                        };
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                _)
                                                                        => {
                                                                            {
                                                                                let seq_res =
                                                                                    {
                                                                                        let assert_res =
                                                                                            parse_eol(input,
                                                                                                      state,
                                                                                                      pos);
                                                                                        match assert_res
                                                                                            {
                                                                                            Failed
                                                                                            =>
                                                                                            Matched(pos,
                                                                                                    ()),
                                                                                            Matched(..)
                                                                                            =>
                                                                                            Failed,
                                                                                        }
                                                                                    };
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let seq_res =
                                                                                                any_char(input,
                                                                                                         state,
                                                                                                         pos);
                                                                                            match seq_res
                                                                                                {
                                                                                                Matched(pos,
                                                                                                        c)
                                                                                                =>
                                                                                                {
                                                                                                    {
                                                                                                        let match_str =
                                                                                                            &input[start_pos..pos];
                                                                                                        Matched(pos,
                                                                                                                {
                                                                                                                    c
                                                                                                                })
                                                                                                    }
                                                                                                }
                                                                                                Failed
                                                                                                =>
                                                                                                Failed,
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    };
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    }
                                    Failed => { break ; }
                                }
                            }
                            if repeat_value.len() >= 1usize {
                                Matched(repeat_pos, repeat_value)
                            } else { Failed }
                        };
                    match seq_res {
                        Matched(pos, b) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Ast::Buffer(b.to_string()) })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_escapekeys<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<()> {
    {
        let choice_res = slice_eq(input, state, pos, "rb");
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res = slice_eq(input, state, pos, "lb");
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res = slice_eq(input, state, pos, "s");
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    slice_eq(input, state, pos, "n");
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    slice_eq(input, state, pos, "r"),
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_escapes<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<Ast> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_opentag(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = slice_eq(input, state, pos, "~");
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_escapekeys(input, state, pos);
                                    match seq_res {
                                        Matched(pos, k) => {
                                            {
                                                let seq_res =
                                                    parse_closetag(input,
                                                                   state,
                                                                   pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let match_str =
                                                                &input[start_pos..pos];
                                                            Matched(pos,
                                                                    {
                                                                        Ast::Escape(k)
                                                                    })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_commentopen<'input>(input: &'input str,
                             state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<()> {
    {
        let seq_res = parse_opentag(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "*") }
            Failed => Failed,
        }
    }
}
fn parse_commentclose<'input>(input: &'input str,
                              state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "*");
        match seq_res {
            Matched(pos, _) => { parse_closetag(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_Comment<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<()> {
    {
        let seq_res = parse_commentopen(input, state, pos);
        match seq_res {
            Matched(pos, _) => {
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    {
                                        let seq_res =
                                            {
                                                let assert_res =
                                                    parse_commentclose(input,
                                                                       state,
                                                                       pos);
                                                match assert_res {
                                                    Failed =>
                                                    Matched(pos, ()),
                                                    Matched(..) => Failed,
                                                }
                                            };
                                        match seq_res {
                                            Matched(pos, _) => {
                                                any_char(input, state, pos)
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, ())
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            parse_commentclose(input, state, pos)
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_filler<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<()> {
    {
        let mut repeat_pos = pos;
        loop  {
            let pos = repeat_pos;
            let step_res =
                {
                    let choice_res = parse_ws(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => parse_Comment(input, state, pos),
                    }
                };
            match step_res {
                Matched(newpos, value) => { repeat_pos = newpos; }
                Failed => { break ; }
            }
        }
        Matched(repeat_pos, ())
    }
}
fn parse_rawopen<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<()> {
    {
        let seq_res = parse_opentag(input, state, pos);
        match seq_res {
            Matched(pos, _) => { slice_eq(input, state, pos, "`") }
            Failed => Failed,
        }
    }
}
fn parse_rawclose<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "`");
        match seq_res {
            Matched(pos, _) => { parse_closetag(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_Raw<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<Ast> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_rawopen(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        {
                                            let start_pos = pos;
                                            {
                                                let seq_res =
                                                    {
                                                        let assert_res =
                                                            parse_rawclose(input,
                                                                           state,
                                                                           pos);
                                                        match assert_res {
                                                            Failed =>
                                                            Matched(pos, ()),
                                                            Matched(..) =>
                                                            Failed,
                                                        }
                                                    };
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                any_char(input,
                                                                         state,
                                                                         pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        c) =>
                                                                {
                                                                    {
                                                                        let match_str =
                                                                            &input[start_pos..pos];
                                                                        Matched(pos,
                                                                                {
                                                                                    c
                                                                                })
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, r) => {
                                {
                                    let seq_res =
                                        parse_rawclose(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            Ast::Raw(r.to_string())
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_FnCreate<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize) -> RuleResult<Ast> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_opentag(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_filler(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "fn");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_filler(input, state,
                                                                 pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                match {
                                                                          let start_pos =
                                                                              pos;
                                                                          {
                                                                              let seq_res =
                                                                                  parse_paramlist(input,
                                                                                                  state,
                                                                                                  pos);
                                                                              match seq_res
                                                                                  {
                                                                                  Matched(pos,
                                                                                          l)
                                                                                  =>
                                                                                  {
                                                                                      {
                                                                                          let seq_res =
                                                                                              parse_filler(input,
                                                                                                           state,
                                                                                                           pos);
                                                                                          match seq_res
                                                                                              {
                                                                                              Matched(pos,
                                                                                                      _)
                                                                                              =>
                                                                                              {
                                                                                                  {
                                                                                                      let match_str =
                                                                                                          &input[start_pos..pos];
                                                                                                      Matched(pos,
                                                                                                              {
                                                                                                                  l
                                                                                                              })
                                                                                                  }
                                                                                              }
                                                                                              Failed
                                                                                              =>
                                                                                              Failed,
                                                                                          }
                                                                                      }
                                                                                  }
                                                                                  Failed
                                                                                  =>
                                                                                  Failed,
                                                                              }
                                                                          }
                                                                      } {
                                                                    Matched(newpos,
                                                                            value)
                                                                    => {
                                                                        Matched(newpos,
                                                                                Some(value))
                                                                    }
                                                                    Failed =>
                                                                    {
                                                                        Matched(pos,
                                                                                None)
                                                                    }
                                                                };
                                                            match seq_res {
                                                                Matched(pos,
                                                                        p) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            parse_block(input,
                                                                                        state,
                                                                                        pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    b)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        parse_filler(input,
                                                                                                     state,
                                                                                                     pos);
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let seq_res =
                                                                                                    parse_closetag(input,
                                                                                                                   state,
                                                                                                                   pos);
                                                                                                match seq_res
                                                                                                    {
                                                                                                    Matched(pos,
                                                                                                            _)
                                                                                                    =>
                                                                                                    {
                                                                                                        {
                                                                                                            let match_str =
                                                                                                                &input[start_pos..pos];
                                                                                                            Matched(pos,
                                                                                                                    {
                                                                                                                        Ast::FnCreate(p,
                                                                                                                                      b)
                                                                                                                    })
                                                                                                        }
                                                                                                    }
                                                                                                    Failed
                                                                                                    =>
                                                                                                    Failed,
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_pipesymbol<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<()> {
    slice_eq(input, state, pos, "|")
}
fn parse_Pipe<'input>(input: &'input str, state: &mut ParseState<'input>,
                      pos: usize) -> RuleResult<Ast> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_opentag(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_filler(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_pipestart(input, state, pos);
                                    match seq_res {
                                        Matched(pos, c) => {
                                            {
                                                let seq_res =
                                                    parse_filler(input, state,
                                                                 pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                {
                                                                    let mut repeat_pos =
                                                                        pos;
                                                                    let mut repeat_value =
                                                                        vec!();
                                                                    loop  {
                                                                        let pos =
                                                                            repeat_pos;
                                                                        let step_res =
                                                                            {
                                                                                let start_pos =
                                                                                    pos;
                                                                                {
                                                                                    let seq_res =
                                                                                        parse_pipesymbol(input,
                                                                                                         state,
                                                                                                         pos);
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let seq_res =
                                                                                                    parse_pipecontinue(input,
                                                                                                                       state,
                                                                                                                       pos);
                                                                                                match seq_res
                                                                                                    {
                                                                                                    Matched(pos,
                                                                                                            c)
                                                                                                    =>
                                                                                                    {
                                                                                                        {
                                                                                                            let match_str =
                                                                                                                &input[start_pos..pos];
                                                                                                            Matched(pos,
                                                                                                                    {
                                                                                                                        c
                                                                                                                    })
                                                                                                        }
                                                                                                    }
                                                                                                    Failed
                                                                                                    =>
                                                                                                    Failed,
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            };
                                                                        match step_res
                                                                            {
                                                                            Matched(newpos,
                                                                                    value)
                                                                            =>
                                                                            {
                                                                                repeat_pos
                                                                                    =
                                                                                    newpos;
                                                                                repeat_value.push(value);
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            {
                                                                                break
                                                                                    ;
                                                                            }
                                                                        }
                                                                    }
                                                                    if repeat_value.len()
                                                                           >=
                                                                           1usize
                                                                       {
                                                                        Matched(repeat_pos,
                                                                                repeat_value)
                                                                    } else {
                                                                        Failed
                                                                    }
                                                                };
                                                            match seq_res {
                                                                Matched(pos,
                                                                        etal)
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            parse_filler(input,
                                                                                         state,
                                                                                         pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        parse_closetag(input,
                                                                                                       state,
                                                                                                       pos);
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let match_str =
                                                                                                    &input[start_pos..pos];
                                                                                                Matched(pos,
                                                                                                        {
                                                                                                            Ast::Pipe(c,
                                                                                                                      etal)
                                                                                                        })
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_Call<'input>(input: &'input str, state: &mut ParseState<'input>,
                      pos: usize) -> RuleResult<Ast> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_opentag(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_filler(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_callable(input, state, pos);
                                    match seq_res {
                                        Matched(pos, c) => {
                                            {
                                                let seq_res =
                                                    parse_filler(input, state,
                                                                 pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_paramset(input,
                                                                               state,
                                                                               pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        p) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            parse_filler(input,
                                                                                         state,
                                                                                         pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        parse_closetag(input,
                                                                                                       state,
                                                                                                       pos);
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let match_str =
                                                                                                    &input[start_pos..pos];
                                                                                                Matched(pos,
                                                                                                        {
                                                                                                            Ast::Call(c,
                                                                                                                      p)
                                                                                                        })
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_associativeitem<'input>(input: &'input str,
                                 state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Ast> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, ":");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_key(input, state, pos);
                        match seq_res {
                            Matched(pos, k) => {
                                {
                                    let seq_res =
                                        parse_filler(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_expression(input,
                                                                     state,
                                                                     pos);
                                                match seq_res {
                                                    Matched(pos, v) => {
                                                        {
                                                            let match_str =
                                                                &input[start_pos..pos];
                                                            Matched(pos,
                                                                    {
                                                                        Ast::MapPair(k,
                                                                                     v)
                                                                    })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_Map<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<Ast> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_openarray(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    slice_eq(input, state, pos, ":");
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                parse_closearray(input, state,
                                                                 pos);
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    Ast::Map(None)
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = parse_openarray(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res = parse_filler(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                {
                                                    let mut repeat_pos = pos;
                                                    let mut repeat_value =
                                                        vec!();
                                                    loop  {
                                                        let pos = repeat_pos;
                                                        let step_res =
                                                            {
                                                                let start_pos =
                                                                    pos;
                                                                {
                                                                    let seq_res =
                                                                        parse_associativeitem(input,
                                                                                              state,
                                                                                              pos);
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                e)
                                                                        => {
                                                                            {
                                                                                let seq_res =
                                                                                    parse_filler(input,
                                                                                                 state,
                                                                                                 pos);
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let match_str =
                                                                                                &input[start_pos..pos];
                                                                                            Matched(pos,
                                                                                                    {
                                                                                                        e
                                                                                                    })
                                                                                        }
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            };
                                                        match step_res {
                                                            Matched(newpos,
                                                                    value) =>
                                                            {
                                                                repeat_pos =
                                                                    newpos;
                                                                repeat_value.push(value);
                                                            }
                                                            Failed => {
                                                                break ;
                                                            }
                                                        }
                                                    }
                                                    if repeat_value.len() >=
                                                           1usize {
                                                        Matched(repeat_pos,
                                                                repeat_value)
                                                    } else { Failed }
                                                };
                                            match seq_res {
                                                Matched(pos, a) => {
                                                    {
                                                        let seq_res =
                                                            parse_filler(input,
                                                                         state,
                                                                         pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        parse_closearray(input,
                                                                                         state,
                                                                                         pos);
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                _)
                                                                        => {
                                                                            {
                                                                                let match_str =
                                                                                    &input[start_pos..pos];
                                                                                Matched(pos,
                                                                                        {
                                                                                            Ast::Map(Some(a))
                                                                                        })
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_Array<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<Ast> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_openarray(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_closearray(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos, { Ast::Array(None) })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = parse_openarray(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res = parse_filler(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                {
                                                    let mut repeat_pos = pos;
                                                    let mut repeat_value =
                                                        vec!();
                                                    loop  {
                                                        let pos = repeat_pos;
                                                        let step_res =
                                                            {
                                                                let start_pos =
                                                                    pos;
                                                                {
                                                                    let seq_res =
                                                                        parse_expression(input,
                                                                                         state,
                                                                                         pos);
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                e)
                                                                        => {
                                                                            {
                                                                                let seq_res =
                                                                                    parse_filler(input,
                                                                                                 state,
                                                                                                 pos);
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let match_str =
                                                                                                &input[start_pos..pos];
                                                                                            Matched(pos,
                                                                                                    {
                                                                                                        e
                                                                                                    })
                                                                                        }
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            };
                                                        match step_res {
                                                            Matched(newpos,
                                                                    value) =>
                                                            {
                                                                repeat_pos =
                                                                    newpos;
                                                                repeat_value.push(value);
                                                            }
                                                            Failed => {
                                                                break ;
                                                            }
                                                        }
                                                    }
                                                    if repeat_value.len() >=
                                                           1usize {
                                                        Matched(repeat_pos,
                                                                repeat_value)
                                                    } else { Failed }
                                                };
                                            match seq_res {
                                                Matched(pos, a) => {
                                                    {
                                                        let seq_res =
                                                            parse_filler(input,
                                                                         state,
                                                                         pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        parse_closearray(input,
                                                                                         state,
                                                                                         pos);
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                _)
                                                                        => {
                                                                            {
                                                                                let match_str =
                                                                                    &input[start_pos..pos];
                                                                                Matched(pos,
                                                                                        {
                                                                                            Ast::Array(Some(a))
                                                                                        })
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_Empty<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<Ast> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_opentag(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_closetag(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { Ast::Empty })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_Tag<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<Ast> {
    {
        let choice_res = parse_FnCreate(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res = parse_Pipe(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res = parse_Call(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res = parse_Raw(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            parse_escapes(input, state, pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed =>
                                            parse_Empty(input, state, pos),
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_expression<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Ast> {
    {
        let choice_res = parse_Tag(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res = parse_literal(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res = parse_Map(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_Array(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    parse_identifier(input, state, pos),
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_comparators<'input>(input: &'input str,
                             state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Ast> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let choice_res =
                        {
                            let start_pos = pos;
                            {
                                let seq_res =
                                    slice_eq(input, state, pos, "==");
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos, { "eq" })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        };
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => {
                            let choice_res =
                                {
                                    let start_pos = pos;
                                    {
                                        let seq_res =
                                            slice_eq(input, state, pos, "!=");
                                        match seq_res {
                                            Matched(pos, _) => {
                                                {
                                                    let match_str =
                                                        &input[start_pos..pos];
                                                    Matched(pos, { "neq" })
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                };
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        {
                                            let start_pos = pos;
                                            {
                                                let seq_res =
                                                    slice_eq(input, state,
                                                             pos, "<=");
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let match_str =
                                                                &input[start_pos..pos];
                                                            Matched(pos,
                                                                    { "lte" })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        };
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed => {
                                            let choice_res =
                                                {
                                                    let start_pos = pos;
                                                    {
                                                        let seq_res =
                                                            slice_eq(input,
                                                                     state,
                                                                     pos,
                                                                     ">=");
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let match_str =
                                                                        &input[start_pos..pos];
                                                                    Matched(pos,
                                                                            {
                                                                                "gte"
                                                                            })
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                };
                                            match choice_res {
                                                Matched(pos, value) =>
                                                Matched(pos, value),
                                                Failed => {
                                                    let choice_res =
                                                        {
                                                            let start_pos =
                                                                pos;
                                                            {
                                                                let seq_res =
                                                                    slice_eq(input,
                                                                             state,
                                                                             pos,
                                                                             "<");
                                                                match seq_res
                                                                    {
                                                                    Matched(pos,
                                                                            _)
                                                                    => {
                                                                        {
                                                                            let match_str =
                                                                                &input[start_pos..pos];
                                                                            Matched(pos,
                                                                                    {
                                                                                        "lt"
                                                                                    })
                                                                        }
                                                                    }
                                                                    Failed =>
                                                                    Failed,
                                                                }
                                                            }
                                                        };
                                                    match choice_res {
                                                        Matched(pos, value) =>
                                                        Matched(pos, value),
                                                        Failed => {
                                                            let choice_res =
                                                                {
                                                                    let start_pos =
                                                                        pos;
                                                                    {
                                                                        let seq_res =
                                                                            slice_eq(input,
                                                                                     state,
                                                                                     pos,
                                                                                     ">");
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        &input[start_pos..pos];
                                                                                    Matched(pos,
                                                                                            {
                                                                                                "gt"
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                };
                                                            match choice_res {
                                                                Matched(pos,
                                                                        value)
                                                                =>
                                                                Matched(pos,
                                                                        value),
                                                                Failed => {
                                                                    let choice_res =
                                                                        {
                                                                            let start_pos =
                                                                                pos;
                                                                            {
                                                                                let seq_res =
                                                                                    slice_eq(input,
                                                                                             state,
                                                                                             pos,
                                                                                             "and");
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let match_str =
                                                                                                &input[start_pos..pos];
                                                                                            Matched(pos,
                                                                                                    {
                                                                                                        "cmpand"
                                                                                                    })
                                                                                        }
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        };
                                                                    match choice_res
                                                                        {
                                                                        Matched(pos,
                                                                                value)
                                                                        =>
                                                                        Matched(pos,
                                                                                value),
                                                                        Failed
                                                                        => {
                                                                            let choice_res =
                                                                                {
                                                                                    let start_pos =
                                                                                        pos;
                                                                                    {
                                                                                        let seq_res =
                                                                                            slice_eq(input,
                                                                                                     state,
                                                                                                     pos,
                                                                                                     "or");
                                                                                        match seq_res
                                                                                            {
                                                                                            Matched(pos,
                                                                                                    _)
                                                                                            =>
                                                                                            {
                                                                                                {
                                                                                                    let match_str =
                                                                                                        &input[start_pos..pos];
                                                                                                    Matched(pos,
                                                                                                            {
                                                                                                                "cmpor"
                                                                                                            })
                                                                                                }
                                                                                            }
                                                                                            Failed
                                                                                            =>
                                                                                            Failed,
                                                                                        }
                                                                                    }
                                                                                };
                                                                            match choice_res
                                                                                {
                                                                                Matched(pos,
                                                                                        value)
                                                                                =>
                                                                                Matched(pos,
                                                                                        value),
                                                                                Failed
                                                                                =>
                                                                                {
                                                                                    let start_pos =
                                                                                        pos;
                                                                                    {
                                                                                        let seq_res =
                                                                                            slice_eq(input,
                                                                                                     state,
                                                                                                     pos,
                                                                                                     "not");
                                                                                        match seq_res
                                                                                            {
                                                                                            Matched(pos,
                                                                                                    _)
                                                                                            =>
                                                                                            {
                                                                                                {
                                                                                                    let match_str =
                                                                                                        &input[start_pos..pos];
                                                                                                    Matched(pos,
                                                                                                            {
                                                                                                                "not"
                                                                                                            })
                                                                                                }
                                                                                            }
                                                                                            Failed
                                                                                            =>
                                                                                            Failed,
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
            match seq_res {
                Matched(pos, c) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, { Ast::Identifier(None, Some(c)) })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_mathators<'input>(input: &'input str, state: &mut ParseState<'input>,
                           pos: usize) -> RuleResult<Ast> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let choice_res =
                        {
                            let start_pos = pos;
                            {
                                let seq_res =
                                    slice_eq(input, state, pos, "+");
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos, { "add" })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        };
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => {
                            let choice_res =
                                {
                                    let start_pos = pos;
                                    {
                                        let seq_res =
                                            slice_eq(input, state, pos, "-");
                                        match seq_res {
                                            Matched(pos, _) => {
                                                {
                                                    let match_str =
                                                        &input[start_pos..pos];
                                                    Matched(pos, { "sub" })
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                };
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        {
                                            let start_pos = pos;
                                            {
                                                let seq_res =
                                                    slice_eq(input, state,
                                                             pos, "*");
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let match_str =
                                                                &input[start_pos..pos];
                                                            Matched(pos,
                                                                    { "mul" })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        };
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed => {
                                            let choice_res =
                                                {
                                                    let start_pos = pos;
                                                    {
                                                        let seq_res =
                                                            slice_eq(input,
                                                                     state,
                                                                     pos,
                                                                     "/");
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let match_str =
                                                                        &input[start_pos..pos];
                                                                    Matched(pos,
                                                                            {
                                                                                "div"
                                                                            })
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                };
                                            match choice_res {
                                                Matched(pos, value) =>
                                                Matched(pos, value),
                                                Failed => {
                                                    let start_pos = pos;
                                                    {
                                                        let seq_res =
                                                            slice_eq(input,
                                                                     state,
                                                                     pos,
                                                                     "%");
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let match_str =
                                                                        &input[start_pos..pos];
                                                                    Matched(pos,
                                                                            {
                                                                                "mod"
                                                                            })
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
            match seq_res {
                Matched(pos, c) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, { Ast::Identifier(None, Some(c)) })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_callable<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize) -> RuleResult<Ast> {
    {
        let choice_res = parse_FnCreate(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res = parse_comparators(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res = parse_mathators(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => parse_identifier(input, state, pos),
                        }
                    }
                }
            }
        }
    }
}
fn parse_pipestart<'input>(input: &'input str, state: &mut ParseState<'input>,
                           pos: usize) -> RuleResult<Ast> {
    {
        let choice_res = parse_FnCreate(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res = parse_Map(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res = parse_Array(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_literal(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    parse_identifier(input, state, pos),
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_pipecontinue<'input>(input: &'input str,
                              state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Ast> {
    {
        let choice_res = parse_FnCreate(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => parse_identifier(input, state, pos),
        }
    }
}
